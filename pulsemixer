#!/usr/bin/env python3
'''
Usage of pulsemixer:
  -h, --help               show this help message and exit
  -v, --version            print version
  -l, --list               list everything
  --list-sources           list sources
  --list-sinks             list sinks
  --id ID                  specify ID. If no ID specified - master sink is used
  --set-volume n           set volume for ID
  --set-volume-all n:n     set volume for ID (for every channel)
  --change-volume +-n      change volume for ID
  --get-mute               get mute for ID
  --toggle-mute            toggle mute for ID
  --get-volume             get volume for ID
  --mute                   mute ID
  --unmute                 unmute ID
'''

VERSION = '1.0.0'

from ctypes import *
import sys
import curses
import re
import getopt
import signal
from os import environ
from base64 import b64encode
from pprint import pprint

#########################################################################################
# v bindings

try:
    p = CDLL("libpulse.so.0")
except Exception as err:
    sys.exit(err)

PA_VOLUME_NORM = 65536
PA_CHANNELS_MAX = 32
PA_USEC_T = c_uint64


class PA_MAINLOOP(Structure):
    pass


class PA_STREAM(Structure):
    pass


class PA_MAINLOOP_API(Structure):
    pass


class PA_CONTEXT(Structure):
    pass


class PA_OPERATION(Structure):
    pass


class PA_IO_EVENT(Structure):
    pass


class PA_SAMPLE_SPEC(Structure):
    _fields_ = [
        ("format", c_int),
        ("rate", c_uint32),
        ("channels", c_uint32)
    ]


class PA_CHANNEL_MAP(Structure):
    _fields_ = [
        ("channels", c_uint8),
        ("map", c_int * PA_CHANNELS_MAX)
    ]


class PA_CVOLUME(Structure):
    _fields_ = [
        ("channels", c_uint8),
        ("values", c_uint32 * PA_CHANNELS_MAX)
    ]


class PA_PORT_INFO(Structure):
    _fields_ = [
        ('name', c_char_p),
        ('description', c_char_p),
        ('priority', c_uint32),
    ]


class PA_SINK_INPUT_INFO(Structure):
    _fields_ = [
        ("index",           c_uint32),
        ("name",            c_char_p),
        ("owner_module",    c_uint32),
        ("client",          c_uint32),
        ("sink",            c_uint32),
        ("sample_spec",     PA_SAMPLE_SPEC),
        ("channel_map",     PA_CHANNEL_MAP),
        ("volume",          PA_CVOLUME),
        ("buffer_usec",     PA_USEC_T),
        ("sink_usec",       PA_USEC_T),
        ("resample_method", c_char_p),
        ("driver",          c_char_p),
        ("mute",            c_int)
    ]


class PA_SINK_INFO(Structure):
    _fields_ = [
        ("name",                c_char_p),
        ("index",               c_uint32),
        ("description",         c_char_p),
        ("sample_spec",         PA_SAMPLE_SPEC),
        ("channel_map",         PA_CHANNEL_MAP),
        ("owner_module",        c_uint32),
        ("volume",              PA_CVOLUME),
        ("mute",                c_int),
        ("monitor_source",      c_uint32),
        ("monitor_source_name", c_char_p),
        ("latency",             PA_USEC_T),
        ("driver",              c_char_p),
        ("flags",               c_int),
        ("proplist",            POINTER(c_int)),
        ("configured_latency",  PA_USEC_T),
        ('base_volume',         c_int),
        ('state',               c_int),
        ('n_volume_steps',      c_int),
        ('card',                c_uint32),
        ('n_ports',             c_uint32),
        ('ports',               POINTER(POINTER(PA_PORT_INFO))),
        ('active_port',         POINTER(PA_PORT_INFO))
    ]


class PA_SOURCE_OUTPUT_INFO(Structure):
    _fields_ = [
        ("index",           c_uint32),
        ("name",            c_char_p),
        ("owner_module",    c_uint32),
        ("client",          c_uint32),
        ("source",          c_uint32),
        ("sample_spec",     PA_SAMPLE_SPEC),
        ("channel_map",     PA_CHANNEL_MAP),
        ("buffer_usec",     PA_USEC_T),
        ("source_usec",     PA_USEC_T),
        ("resample_method", c_char_p),
        ("driver",          c_char_p),
        ("proplist",        POINTER(c_int)),
        ("corked",          c_int),
        ("volume",          PA_CVOLUME),
        ("mute",            c_int),
        ('has_volume',      c_int),
        ('volume_writable', c_int),
    ]


class PA_SOURCE_INFO(Structure):
    _fields_ = [
        ("name",                 c_char_p),
        ("index",                c_uint32),
        ("description",          c_char_p),
        ("sample_spec",          PA_SAMPLE_SPEC),
        ("channel_map",          PA_CHANNEL_MAP),
        ("owner_module",         c_uint32),
        ("volume",               PA_CVOLUME),
        ("mute",                 c_int),
        ("monitor_of_sink",      c_uint32),
        ("monitor_of_sink_name", c_char_p),
        ("latency",              PA_USEC_T),
        ("driver",               c_char_p),
        ("flags",                c_int),
        ("proplist",             POINTER(c_int)),
        ("configured_latency",   PA_USEC_T),
        ('base_volume',          c_int),
        ('state',                c_int),
        ('n_volume_steps',       c_int),
        ('card',                 c_uint32),
        ('n_ports',              c_uint32),
        ('ports',                POINTER(POINTER(PA_PORT_INFO))),
        ('active_port',          POINTER(PA_PORT_INFO))
    ]


class PA_CLIENT_INFO(Structure):
    _fields_ = [
        ("index",        c_uint32),
        ("name",         c_char_p),
        ("owner_module", c_uint32),
        ("driver",       c_char_p)
    ]


class PA_CARD_PROFILE_INFO(Structure):
    _fields_ = [
        ('name', c_char_p),
        ('description', c_char_p),
        ('n_sinks', c_uint32),
        ('n_sources', c_uint32),
        ('priority', c_uint32),
    ]


class PA_CARD_INFO(Structure):
    _fields_ = [
        ('index', c_uint32),
        ('name', c_char_p),
        ('owner_module', c_uint32),
        ('driver', c_char_p),
        ('n_profiles', c_uint32),
        ('profiles', POINTER(PA_CARD_PROFILE_INFO)),
        ('active_profile', POINTER(PA_CARD_PROFILE_INFO)),
        ('proplist', POINTER(c_int)),
    ]

PA_SIGNAL_CB_T = CFUNCTYPE(c_void_p,
                           POINTER(PA_MAINLOOP_API),
                           POINTER(c_int),
                           c_int,
                           c_void_p)

PA_STATE_CB_T = CFUNCTYPE(c_int,
                          POINTER(PA_CONTEXT),
                          c_void_p)

PA_CLIENT_INFO_CB_T = CFUNCTYPE(c_void_p,
                                POINTER(PA_CONTEXT),
                                POINTER(PA_CLIENT_INFO),
                                c_int,
                                c_void_p)

PA_SINK_INPUT_INFO_CB_T = CFUNCTYPE(c_int,
                                    POINTER(PA_CONTEXT),
                                    POINTER(PA_SINK_INPUT_INFO),
                                    c_int,
                                    c_void_p)

PA_SINK_INFO_CB_T = CFUNCTYPE(c_int,
                              POINTER(PA_CONTEXT),
                              POINTER(PA_SINK_INFO),
                              c_int,
                              c_void_p)

PA_SOURCE_OUTPUT_INFO_CB_T = CFUNCTYPE(c_int,
                                       POINTER(PA_CONTEXT),
                                       POINTER(PA_SOURCE_OUTPUT_INFO),
                                       c_int,
                                       c_void_p)

PA_SOURCE_INFO_CB_T = CFUNCTYPE(c_int,
                                POINTER(PA_CONTEXT),
                                POINTER(PA_SOURCE_INFO),
                                c_int,
                                c_void_p)

PA_CONTEXT_DRAIN_CB_T = CFUNCTYPE(c_void_p,
                                  POINTER(PA_CONTEXT),
                                  c_void_p)

PA_CONTEXT_SUCCESS_CB_T = CFUNCTYPE(c_void_p,
                                    POINTER(PA_CONTEXT),
                                    c_int,
                                    c_void_p)

PA_CARD_INFO_CB_T = CFUNCTYPE(None,
                              POINTER(PA_CONTEXT),
                              POINTER(PA_CARD_INFO),
                              c_int,
                              c_void_p)

pa_strerror = p.pa_strerror
pa_strerror.restype = c_char_p
pa_strerror.argtypes = [c_int]

pa_mainloop_new = p.pa_mainloop_new
pa_mainloop_new.restype = POINTER(PA_MAINLOOP)
pa_mainloop_new.argtypes = []

pa_mainloop_get_api = p.pa_mainloop_get_api
pa_mainloop_get_api.restype = POINTER(PA_MAINLOOP_API)
pa_mainloop_get_api.argtypes = [POINTER(PA_MAINLOOP)]

pa_mainloop_run = p.pa_mainloop_run
pa_mainloop_run.restype = c_int
pa_mainloop_run.argtypes = [POINTER(PA_MAINLOOP), POINTER(c_int)]

pa_mainloop_iterate = p.pa_mainloop_iterate
pa_mainloop_iterate.restype = c_int
pa_mainloop_iterate.argtypes = [POINTER(PA_MAINLOOP), c_int, POINTER(c_int)]

pa_mainloop_quit = p.pa_mainloop_quit
pa_mainloop_quit.restype = c_int
pa_mainloop_quit.argtypes = [POINTER(PA_MAINLOOP), c_int]

pa_mainloop_dispatch = p.pa_mainloop_dispatch
pa_mainloop_dispatch.restype = c_int
pa_mainloop_dispatch.argtypes = [POINTER(PA_MAINLOOP)]

pa_mainloop_free = p.pa_mainloop_run
pa_mainloop_free.restype = c_int
pa_mainloop_free.argtypes = [POINTER(PA_MAINLOOP)]

pa_signal_init = p.pa_signal_init
pa_signal_init.restype = c_int
pa_signal_init.argtypes = [POINTER(PA_MAINLOOP_API)]

pa_signal_new = p.pa_signal_new
pa_signal_new.restype = None
pa_signal_new.argtypes = [c_int, PA_SIGNAL_CB_T, POINTER(c_int)]

pa_context_errno = p.pa_context_errno
pa_context_errno.restype = c_int
pa_context_errno.argtypes = [POINTER(PA_CONTEXT)]

pa_context_new = p.pa_context_new
pa_context_new.restype = POINTER(PA_CONTEXT)
pa_context_new.argtypes = [POINTER(PA_MAINLOOP_API), c_char_p]

pa_context_set_state_callback = p.pa_context_set_state_callback
pa_context_set_state_callback.restype = None
pa_context_set_state_callback.argtypes = [
    POINTER(PA_CONTEXT),
    PA_STATE_CB_T,
    c_void_p
]

pa_context_connect = p.pa_context_connect
pa_context_connect.restype = c_int
pa_context_connect.argtypes = [
    POINTER(PA_CONTEXT),
    c_char_p,
    c_int,
    POINTER(c_int)
]

pa_context_get_state = p.pa_context_get_state
pa_context_get_state.restype = c_int
pa_context_get_state.argtypes = [POINTER(PA_CONTEXT)]

pa_context_drain = p.pa_context_drain
pa_context_drain.restype = POINTER(PA_OPERATION)
pa_context_drain.argtypes = [
    POINTER(PA_CONTEXT),
    PA_CONTEXT_DRAIN_CB_T,
    c_void_p
]

pa_context_disconnect = p.pa_context_disconnect
pa_context_disconnect.restype = c_int
pa_context_disconnect.argtypes = [POINTER(PA_CONTEXT)]

pa_context_get_sink_input_info_list = p.pa_context_get_sink_input_info_list
pa_context_get_sink_input_info_list.restype = POINTER(c_int)
pa_context_get_sink_input_info_list.argtypes = [
    POINTER(PA_CONTEXT),
    PA_SINK_INPUT_INFO_CB_T,
    c_void_p
]

pa_context_get_sink_info_list = p.pa_context_get_sink_info_list
pa_context_get_sink_info_list.restype = POINTER(c_int)
pa_context_get_sink_info_list.argtypes = [
    POINTER(PA_CONTEXT),
    PA_SINK_INFO_CB_T,
    c_void_p
]

pa_context_set_sink_mute_by_index = p.pa_context_set_sink_mute_by_index
pa_context_set_sink_mute_by_index.restype = POINTER(c_int)
pa_context_set_sink_mute_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_int,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_suspend_sink_by_index = p.pa_context_suspend_sink_by_index
pa_context_suspend_sink_by_index.restype = POINTER(c_int)
pa_context_suspend_sink_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_int,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_sink_port_by_index = p.pa_context_set_sink_port_by_index
pa_context_set_sink_port_by_index.restype = POINTER(c_int)
pa_context_set_sink_port_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_char_p,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_sink_input_mute = p.pa_context_set_sink_input_mute
pa_context_set_sink_input_mute.restype = POINTER(c_int)
pa_context_set_sink_input_mute.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_int,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_sink_volume_by_index = p.pa_context_set_sink_volume_by_index
pa_context_set_sink_volume_by_index.restype = POINTER(c_int)
pa_context_set_sink_volume_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    POINTER(PA_CVOLUME),
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_sink_input_volume = p.pa_context_set_sink_input_volume
pa_context_set_sink_input_volume.restype = POINTER(c_int)
pa_context_set_sink_input_volume.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    POINTER(PA_CVOLUME),
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_move_sink_input_by_index = p.pa_context_move_sink_input_by_index
pa_context_move_sink_input_by_index.restype = POINTER(c_int)
pa_context_move_sink_input_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_uint32,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_get_source_output_info = p.pa_context_get_source_output_info
pa_context_get_source_output_info.restype = POINTER(c_int)
pa_context_get_source_output_info.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    PA_SOURCE_OUTPUT_INFO_CB_T,
    c_void_p
]

pa_context_get_source_output_info_list = p.pa_context_get_source_output_info_list
pa_context_get_source_output_info_list.restype = POINTER(c_int)
pa_context_get_source_output_info_list.argtypes = [
    POINTER(PA_CONTEXT),
    PA_SOURCE_OUTPUT_INFO_CB_T,
    c_void_p
]

pa_context_move_source_output_by_index = p.pa_context_move_source_output_by_index
pa_context_move_source_output_by_index.restype = POINTER(c_int)
pa_context_move_source_output_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_uint32,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_source_output_volume = p.pa_context_set_source_output_volume
pa_context_set_source_output_volume.restype = POINTER(c_int)
pa_context_set_source_output_volume.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    POINTER(PA_CVOLUME),
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_source_output_mute = p.pa_context_set_source_output_mute
pa_context_set_source_output_mute.restype = POINTER(c_int)
pa_context_set_source_output_mute.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_int,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_kill_source_output = p.pa_context_kill_source_output
pa_context_kill_source_output.restype = POINTER(c_int)
pa_context_kill_source_output.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_get_source_info_by_index = p.pa_context_get_source_info_by_index
pa_context_get_source_info_by_index.restype = POINTER(c_int)
pa_context_get_source_info_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    PA_SOURCE_INFO_CB_T,
    c_void_p
]

pa_context_get_source_info_list = p.pa_context_get_source_info_list
pa_context_get_source_info_list.restype = POINTER(c_int)
pa_context_get_source_info_list.argtypes = [
    POINTER(PA_CONTEXT),
    PA_SOURCE_INFO_CB_T,
    c_void_p
]

pa_context_set_source_volume_by_index = p.pa_context_set_source_volume_by_index
pa_context_set_source_volume_by_index.restype = POINTER(c_int)
pa_context_set_source_volume_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    POINTER(PA_CVOLUME),
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_source_volume_by_index = p.pa_context_set_source_volume_by_index
pa_context_set_source_volume_by_index.restype = POINTER(c_int)
pa_context_set_source_volume_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    POINTER(PA_CVOLUME),
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_source_mute_by_index = p.pa_context_set_source_mute_by_index
pa_context_set_source_mute_by_index.restype = POINTER(c_int)
pa_context_set_source_mute_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_int,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_suspend_source_by_index = p.pa_context_suspend_source_by_index
pa_context_suspend_source_by_index.restype = POINTER(c_int)
pa_context_suspend_source_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_int,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_set_source_port_by_index = p.pa_context_set_source_port_by_index
pa_context_set_source_port_by_index.restype = POINTER(c_int)
pa_context_set_source_port_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_char_p,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

pa_context_get_client_info_list = p.pa_context_get_client_info_list
pa_context_get_client_info_list.restype = POINTER(c_int)
pa_context_get_client_info_list.argtypes = [
    POINTER(PA_CONTEXT),
    PA_CLIENT_INFO_CB_T,
    c_void_p
]

pa_context_get_client_info = p.pa_context_get_client_info
pa_context_get_client_info.restype = POINTER(c_int)
pa_context_get_client_info.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    PA_CLIENT_INFO_CB_T,
    c_void_p
]

pa_operation_unref = p.pa_operation_unref
pa_operation_unref.restype = c_int
pa_operation_unref.argtypes = [POINTER(PA_OPERATION)]

pa_context_get_card_info_by_index = p.pa_context_get_card_info_by_index
pa_context_get_card_info_by_index.restype = POINTER(PA_OPERATION)
pa_context_get_card_info_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    PA_CARD_INFO_CB_T,
    c_void_p
]

pa_context_get_card_info_list = p.pa_context_get_card_info_list
pa_context_get_card_info_list.restype = POINTER(PA_OPERATION)
pa_context_get_card_info_list.argtypes = [
    POINTER(PA_CONTEXT),
    PA_CARD_INFO_CB_T,
    c_void_p
]

pa_context_set_card_profile_by_index = p.pa_context_set_card_profile_by_index
pa_context_set_card_profile_by_index.restype = POINTER(PA_OPERATION)
pa_context_set_card_profile_by_index.argtypes = [
    POINTER(PA_CONTEXT),
    c_uint32,
    c_char_p,
    PA_CONTEXT_SUCCESS_CB_T,
    c_void_p
]

# ^ bindings
#########################################################################################
# v lib


class PulsePort():

    def __init__(self, pa_port):
        self.name = pa_port.name
        self.description = pa_port.description
        self.priority = pa_port.priority

    def debug(self):
        pprint(vars(self))


class PulseCard():

    def __init__(self, name, index=0):
        self.index = index
        self.name = name

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        return "Card-ID: {}, Name: {}".format(self.index, self.name.decode())


class PulseCardC(PulseCard):

    def __init__(self, pa_card):
        PulseCard.__init__(self, pa_card.name, pa_card.index)
        self.driver = pa_card.driver
        self.owner_module = pa_card.owner_module
        self.n_profiles = pa_card.n_profiles

    def debug(self):
        pprint(vars(self))


class PulseClient():

    def __init__(self, name, index=0):
        self.index = index
        self.name = name

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        return "Client-name: {}".format(self.name.decode())


class PulseClientC(PulseClient):

    def __init__(self, pa_client):
        PulseClient.__init__(self, pa_client.name, pa_client.index)
        self.driver = pa_client.driver
        self.owner_module = pa_client.owner_module

    def debug(self):
        pprint(vars(self))


class Pulse():

    def __init__(self, client_name=None, server=None, retry=False):
        self.server = server
        self.ret = None
        self.retry = retry
        self.context = None
        self.operation = None
        self.connected = False
        self.action_done = False
        self.data = []
        self.mainloop = None
        self.mainloop_api = None
        self.client_name = (client_name or 'libpulse').encode()

        self.pa_signal_cb = PA_SIGNAL_CB_T(self.signal_cb)
        self.pa_state_cb = PA_STATE_CB_T(self.state_cb)

        self.mainloop = pa_mainloop_new()
        self.mainloop_api = pa_mainloop_get_api(self.mainloop)

        if pa_signal_init(self.mainloop_api) != 0:
            raise Exception("pa_signal_init failed")

        pa_signal_new(2, self.pa_signal_cb, None)
        pa_signal_new(15, self.pa_signal_cb, None)

        self.context = pa_context_new(self.mainloop_api, self.client_name)
        pa_context_set_state_callback(self.context, self.pa_state_cb, None)
        self.start_action()

        if pa_context_connect(self.context, self.server, 0, None) < 0:
            if self.retry:
                pa_context_disconnect(self.context)
                return
            self.pulse_context_error()
        self.pulse_iterate()

    def unmute_stream(self, obj):
        if type(obj) is PulseSinkInfo:
            self.pulse_sink_mute(obj.index, 0)
        elif type(obj) is PulseSinkInputInfo:
            self.pulse_sink_input_mute(obj.index, 0)
        elif type(obj) is PulseSourceInfo:
            self.pulse_source_mute(obj.index, 0)
        elif type(obj) is PulseSourceOutputInfo:
            self.pulse_source_output_mute(obj.index, 0)
        else:
            raise NotImplementedError(type(obj))
        obj.mute = 0

    def mute_stream(self, obj):
        if type(obj) is PulseSinkInfo:
            self.pulse_sink_mute(obj.index, 1)
        elif type(obj) is PulseSinkInputInfo:
            self.pulse_sink_input_mute(obj.index, 1)
        elif type(obj) is PulseSourceInfo:
            self.pulse_source_mute(obj.index, 1)
        elif type(obj) is PulseSourceOutputInfo:
            self.pulse_source_output_mute(obj.index, 1)
        else:
            raise NotImplementedError(type(obj))
        obj.mute = 1

    def set_volume(self, obj, volume):
        if type(obj) is PulseSinkInfo:
            self.pulse_set_sink_volume(obj.index, volume)
        elif type(obj) is PulseSinkInputInfo:
            self.pulse_set_sink_input_volume(obj.index, volume)
        elif type(obj) is PulseSourceInfo:
            self.pulse_set_source_volume(obj.index, volume)
        elif type(obj) is PulseSourceOutputInfo:
            self.pulse_set_source_output_volume(obj.index, volume)
        else:
            raise NotImplementedError(type(obj))
        obj.volume = volume

    def change_volume_mono(self, obj, inc):
        obj.volume.values = [v + inc for v in obj.volume.values]
        self.set_volume(obj, obj.volume)

    def get_volume_mono(self, obj):
        return int(sum(obj.volume.values) / len(obj.volume.values))

    def fill_clients(self):
        if not self.data:
            return
        data, self.data = self.data, []
        clist = self.pulse_client_list()
        for d in data:
            for c in clist:
                if c.index == d.client_id:
                    d.client = c
                    break
        return data

    def signal_cb(self, api, e, sig, userdata):
        if sig == 2 or sig == 15:
            self.pulse_disconnect()
        return 0

    def state_cb(self, c, b):
        state = pa_context_get_state(c)
        if state == 4:
            self.complete_action()
            self.connected = True
        elif state == 5:
            self.connected = False
            self.complete_action()
        elif state == 6:
            if not self.retry:
                sys.exit(pa_context_errno(c))
            self.complete_action()
        return 0

    def _cb(func):
        def wrapper(self, c, info, eof, userdata):
            if eof:
                self.complete_action()
                return 0
            func(self, c, info, eof, userdata)
            return 0
        return wrapper

    @_cb
    def card_cb(self, c, card_info, eof, userdata):
        self.data.append(PulseCardC(card_info[0]))

    @_cb
    def client_cb(self, c, client_info, eof, userdata):
        self.data.append(PulseClientC(client_info[0]))

    @_cb
    def sink_input_cb(self, c, sink_input_info, eof, userdata):
        self.data.append(PulseSinkInputInfo(sink_input_info[0]))

    @_cb
    def sink_cb(self, c, sink_info, eof, userdata):
        self.data.append(PulseSinkInfo(sink_info[0]))

    @_cb
    def source_output_cb(self, c, source_output_info, eof, userdata):
        self.data.append(PulseSourceOutputInfo(source_output_info[0]))

    @_cb
    def source_cb(self, c, source_info, eof, userdata):
        self.data.append(PulseSourceInfo(source_info[0]))

    def context_success(self, c, success, userdata):
        self.complete_action()
        return 0

    def complete_action(self):
        self.action_done = True

    def start_action(self):
        self.action_done = False

    def pulse_disconnect(self):
        pa_context_disconnect(self.context)
        pa_mainloop_free(self.mainloop)

    def pulse_context_error(self):
        self.pulse_disconnect()

    def pulse_sink_input_list(self):
        self.start_action()
        CB = PA_SINK_INPUT_INFO_CB_T(self.sink_input_cb)
        self.operation = pa_context_get_sink_input_info_list(self.context, CB, None)
        self.pulse_iterate()
        data, self.data = self.fill_clients(), []
        return data or []

    def pulse_sink_list(self):
        self.start_action()
        CB = PA_SINK_INFO_CB_T(self.sink_cb)
        self.operation = pa_context_get_sink_info_list(self.context, CB, None)
        self.pulse_iterate()
        data, self.data = self.data, []
        return data or []

    def pulse_source_output_list(self):
        self.start_action()
        CB = PA_SOURCE_OUTPUT_INFO_CB_T(self.source_output_cb)
        self.operation = pa_context_get_source_output_info_list(self.context, CB, None)
        self.pulse_iterate()
        data, self.data = self.fill_clients(), []
        return data or []

    def pulse_source_list(self):
        self.start_action()
        CB = PA_SOURCE_INFO_CB_T(self.source_cb)
        self.operation = pa_context_get_source_info_list(self.context, CB, None)
        self.pulse_iterate()
        data, self.data = self.data, []
        return data or []

    def pulse_card_list(self):
        self.start_action()
        CB = PA_CARD_INFO_CB_T(self.card_cb)
        self.operation = pa_context_get_card_info_list(self.context, CB, None)
        self.pulse_iterate()
        data, self.data = self.data, []
        return data or []

    def pulse_client_list(self):
        self.start_action()
        CB = PA_CLIENT_INFO_CB_T(self.client_cb)
        self.operation = pa_context_get_client_info_list(self.context, CB, None)
        self.pulse_iterate()
        data, self.data = self.data, []
        return data or []

    def pulse_sink_input_mute(self, index, mute):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_sink_input_mute(self.context,
                                                        index, mute,
                                                        CONTEXT, None)
        self.pulse_iterate()

    def pulse_sink_input_move(self, index, sink_index):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_move_sink_input_by_index(self.context,
                                                             index, sink_index,
                                                             CONTEXT, None)
        self.pulse_iterate()

    def pulse_sink_mute(self, index, mute):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_sink_mute_by_index(self.context,
                                                           index, mute,
                                                           CONTEXT, None)
        self.pulse_iterate()

    def pulse_set_sink_input_volume(self, index, vol):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_sink_input_volume(self.context,
                                                          index, vol.to_c(),
                                                          CONTEXT, None)
        self.pulse_iterate()

    def pulse_set_sink_volume(self, index, vol):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_sink_volume_by_index(self.context,
                                                             index, vol.to_c(),
                                                             CONTEXT, None)
        self.pulse_iterate()

    def pulse_sink_suspend(self, index, suspend):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_suspend_sink_by_index(self.context,
                                                          index, suspend,
                                                          CONTEXT, None)
        self.pulse_iterate()

    def pulse_set_sink_port(self, index, port):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_sink_port_by_index(self.context,
                                                           index, port,
                                                           CONTEXT, None)
        self.pulse_iterate()

    def pulse_set_source_output_volume(self, index, vol):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_source_output_volume(self.context,
                                                             index, vol.to_c(),
                                                             CONTEXT, None)
        self.pulse_iterate()

    def pulse_set_source_volume(self, index, vol):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_source_volume_by_index(self.context,
                                                               index, vol.to_c(),
                                                               CONTEXT, None)
        self.pulse_iterate()

    def pulse_source_suspend(self, index, suspend):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_suspend_source_by_index(self.context,
                                                            index, suspend,
                                                            CONTEXT, None)
        self.pulse_iterate()

    def pulse_set_source_port(self, index, port):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_source_port_by_index(self.context,
                                                             index, port,
                                                             CONTEXT, None)
        self.pulse_iterate()

    def pulse_source_output_mute(self, index, mute):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_source_output_mute(self.context,
                                                           index, mute,
                                                           CONTEXT, None)
        self.pulse_iterate()

    def pulse_source_output_move(self, index, sink_index):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_move_source_output_by_index(self.context,
                                                                index, sink_index,
                                                                CONTEXT, None)
        self.pulse_iterate()

    def pulse_source_mute(self, index, mute):
        self.start_action()
        CONTEXT = PA_CONTEXT_SUCCESS_CB_T(self.context_success)
        self.operation = pa_context_set_source_mute_by_index(self.context,
                                                             index, mute,
                                                             CONTEXT, None)
        self.pulse_iterate()

    def reconnect(self):
        self.context = pa_context_new(self.mainloop_api, self.client_name)
        pa_context_set_state_callback(self.context, self.pa_state_cb, None)
        self.start_action()
        if pa_context_connect(self.context, self.server, 0, None) < 0:
            if self.retry:
                pa_context_disconnect(self.context)
                return
            self.pulse_context_error()
        self.pulse_iterate()

    def pulse_run(self):
        self.ret = pointer(c_int(0))
        pa_mainloop_run(self.mainloop, self.ret)

    def pulse_iterate(self, times=1):
        self.ret = pointer(c_int())
        pa_mainloop_iterate(self.mainloop, times, self.ret)
        while not self.action_done:
            pa_mainloop_iterate(self.mainloop, times, self.ret)


class PulseSink():

    def __init__(self, index, name, mute, volume, client):
        self.index = index
        self.name = name
        self.mute = mute
        self.volume = volume
        self.client = client

    def debug(self):
        pprint(vars(self))


class PulseSinkInfo(PulseSink):

    def __init__(self, pa_sink_info):
        PulseSink.__init__(self, pa_sink_info.index,
                           pa_sink_info.name,
                           pa_sink_info.mute,
                           PulseVolumeC(pa_sink_info.volume),
                           PulseClient(self.__class__.__name__.encode()))
        self.description = pa_sink_info.description
        self.sample_spec = pa_sink_info.sample_spec
        self.channel_map = pa_sink_info.channel_map
        self.owner_module = pa_sink_info.owner_module
        self.latency = pa_sink_info.latency
        self.driver = pa_sink_info.driver
        self.monitor_source = pa_sink_info.monitor_source
        self.monitor_source_name = pa_sink_info.monitor_source_name
        self.flags = pa_sink_info.flags
        self.proplist = pa_sink_info.proplist
        self.configured_latency = pa_sink_info.configured_latency
        self.n_ports = pa_sink_info.n_ports
        self.ports = [PulsePort(pa_sink_info.ports[i].contents)
                      for i in range(self.n_ports)]
        self.active_port = None
        if self.n_ports:
            self.active_port = PulsePort(pa_sink_info.active_port.contents)

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        return "ID: {}, Name: {}, Mute: {}, {}".format(
            self.index, self.description.decode(), self.mute, self.volume)


class PulseSinkInputInfo(PulseSink):

    def __init__(self, pa_sink_input_info):
        PulseSink.__init__(self, pa_sink_input_info.index,
                           pa_sink_input_info.name,
                           pa_sink_input_info.mute,
                           PulseVolumeC(pa_sink_input_info.volume),
                           PulseClient(pa_sink_input_info.name))
        self.owner_module = pa_sink_input_info.owner_module
        self.client_id = pa_sink_input_info.client
        self.sink = pa_sink_input_info.sink
        self.channel_map = pa_sink_input_info.channel_map
        self.sample_spec = pa_sink_input_info.sample_spec
        self.buffer_usec = pa_sink_input_info.buffer_usec
        self.sink_usec = pa_sink_input_info.sink_usec
        self.resample_method = pa_sink_input_info.resample_method
        self.driver = pa_sink_input_info.driver

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        if self.client:
            return "ID: {}, Name: {}, Mute: {}, {}".format(
                self.index, self.client.name.decode(), self.mute, self.volume)
        return "ID: {}, Name: {}, Mute: {}".format(
            self.index, self.name.decode(), self.mute)


class PulseSource():

    def __init__(self, index, name, mute, volume, client):
        self.index = index
        self.name = name
        self.mute = mute
        self.client = client
        self.volume = volume

    def debug(self):
        pprint(vars(self))


class PulseSourceInfo(PulseSource):

    def __init__(self, pa_source_info):
        PulseSource.__init__(self, pa_source_info.index,
                             pa_source_info.name,
                             pa_source_info.mute,
                             PulseVolumeC(pa_source_info.volume),
                             PulseClient(self.__class__.__name__.encode()))
        self.description = pa_source_info.description
        self.sample_spec = pa_source_info.sample_spec
        self.channel_map = pa_source_info.channel_map
        self.owner_module = pa_source_info.owner_module
        self.monitor_of_sink = pa_source_info.monitor_of_sink
        self.monitor_of_sink_name = pa_source_info.monitor_of_sink_name
        self.latency = pa_source_info.latency
        self.driver = pa_source_info.driver
        self.flags = pa_source_info.flags
        self.proplist = pa_source_info.proplist
        self.configured_latency = pa_source_info.configured_latency
        self.n_ports = pa_source_info.n_ports
        self.ports = [PulsePort(pa_source_info.ports[i].contents)
                      for i in range(self.n_ports)]
        self.active_port = None
        if self.n_ports:
            self.active_port = PulsePort(pa_source_info.active_port.contents)

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        return "ID: {}, Name: {}, Mute: {}, {}".format(
            self.index, self.description.decode(), self.mute, self.volume)


class PulseSourceOutputInfo(PulseSource):

    def __init__(self, pa_source_output_info):
        PulseSource.__init__(self, pa_source_output_info.index,
                             pa_source_output_info.name,
                             pa_source_output_info.mute,
                             PulseVolumeC(pa_source_output_info.volume),
                             PulseClient(pa_source_output_info.name))
        self.owner_module = pa_source_output_info.owner_module
        self.client_id = pa_source_output_info.client
        self.source = pa_source_output_info.source
        self.sample_spec = pa_source_output_info.sample_spec
        self.channel_map = pa_source_output_info.channel_map
        self.buffer_usec = pa_source_output_info.buffer_usec
        self.source_usec = pa_source_output_info.source_usec
        self.resample_method = pa_source_output_info.resample_method
        self.driver = pa_source_output_info.driver

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        if self.client:
            return "ID: {}, Name: {}, Mute: {}, {}".format(
                self.index, self.client.name.decode(), self.mute, self.volume)
        return "ID: {}, Name: {}, Mute: {}".format(
            self.index, self.name.decode(), self.mute)


class PulseVolume():

    def __init__(self, values=0, channels=2):
        values = max(min(values, 150), 0)
        self.channels = channels
        self.values = [values] * self.channels

    def to_c(self):
        self.values = list(map(lambda x: max(min(x, 150), 0), self.values))
        cvolume = PA_CVOLUME()
        cvolume.channels = self.channels
        for x in range(self.channels):
            cvolume.values[x] = round((self.values[x] * PA_VOLUME_NORM) / 100)
        return cvolume

    def debug(self):
        pprint(vars(self))

    def __str__(self):
        return "Channels: {}, Volumes: {}".format(
            self.channels, [str(x) + "%" for x in self.values])


class PulseVolumeC(PulseVolume):

    def __init__(self, cvolume):
        self.channels = cvolume.channels
        self.values = [(round(x * 100 / PA_VOLUME_NORM))
                       for x in cvolume.values[:self.channels]]

# ^ lib
#########################################################################################
# v main

pulse = Pulse('pulsemixer', retry=True)


class Bar():
    # should be in correct order
    LEFT, RIGHT, RLEFT, RRIGHT, CENTER, SUB, SLEFT, SRIGHT, NONE = range(9)

    def __init__(self, pa):
        if type(pa) is str:
            self.name = pa
            self.fullname = None
            return
        if type(pa) is PulseSinkInfo or type(pa) is PulseSourceInfo:
            self.fullname = pa.description.decode()
        else:
            self.fullname = pa.client.name.decode()
        self.name = re.sub('^ALSA plug-in \[|\]$', '', self.fullname.replace('|', ' '))
        self.index = pa.index
        self.channels = pa.volume.channels
        self.volume = pa.volume.values
        self.maxsize = 150
        self.muted = pa.mute
        self.locked = True
        self.pa = pa
        self.owner = 0

    def poll_data(self, pa):
        self.channels = pa.volume.channels
        self.volume = pa.volume.values
        self.muted = pa.mute
        self.volume = pa.volume.values
        self.pa = pa
        if type(pa) is PulseSourceOutputInfo:
            self.owner = pa.source
        elif type(pa) is PulseSinkInputInfo:
            self.owner = pa.sink

    def mute_toggle(self):
        if self.muted:
            pulse.unmute_stream(self.pa)
        else:
            pulse.mute_stream(self.pa)

    def lock_toggle(self):
        self.locked = not self.locked

    def move(self, n, side):
        vol = self.pa.volume
        if self.locked:
            for i, _ in enumerate(vol.values):
                vol.values[i] += n
        else:
            vol.values[side] += n
        pulse.set_volume(self.pa, vol)


class Screen():
    DOWN = 1
    UP = -1
    SPACE_KEY = 32
    ESC_KEY = 27
    MODE = {1: 1, 2: 0, 3: 0, 4: 0}

    def __init__(self):
        environ['ESCDELAY'] = '25'
        self.screen = curses.initscr()
        self.screen.timeout(500)
        curses.curs_set(0)
        self.screen.border(0)
        self.index = 0
        self.top_line_num = 0
        self.focus_line_num = 0
        self.lines, self.cols = curses.LINES - 1, curses.COLS
        self.info, self.menu = str, str
        self.data = []
        self.modes = [[[], 0, 0] for i in range(5)]
        self.active_mode = 1
        self.old_mode = 1
        self.change_mode_allowed = True
        self.n_lines = 0
        curses.start_color()
        curses.use_default_colors()
        curses.init_pair(1, curses.COLOR_GREEN, -1)
        curses.init_pair(2, curses.COLOR_YELLOW, -1)
        curses.init_pair(3, curses.COLOR_RED, -1)
        self.green = curses.color_pair(1)
        self.yellow = curses.color_pair(2)
        self.red = curses.color_pair(3)
        self.gradient = [self.green, self.yellow, self.red]
        self.submenu_data = []
        self.submenu_show = False
        self.submenu = curses.newwin(curses.LINES, 25, 0, 0)
        self.helpwin_show = False
        self.helpwin = curses.newwin(12, 62, 0, 0)
        try:
            self.helpwin.mvwin((curses.LINES // 2) - 6, (curses.COLS // 2) - 31)
        except:
            pass
        self.selected = None
        self.action = None

    def display_line(self, index, line, mod=curses.A_NORMAL):
        shift = 0
        for s in line.split('\n'):
            p = s.rsplit('|')
            self.screen.addstr(index, shift, ''.join(p[:-1]), int(p[-1]) | mod)
            shift += len(''.join(p[:-1]))

    def change_mode(self, mode):
        if not self.change_mode_allowed:
            return
        self.modes[self.active_mode - 1][1] = self.focus_line_num
        self.modes[self.active_mode - 1][2] = self.top_line_num
        self.old_mode = self.active_mode
        self.MODE = self.MODE.fromkeys(self.MODE, 0)
        self.MODE[mode] = 1
        self.get_data()
        self.focus_line_num = self.modes[mode - 1][1]
        self.top_line_num = self.modes[mode - 1][2]
        self.active_mode = mode

    def next_mode(self):
        for mode, active in self.MODE.items():
            if active == 1:
                self.change_mode(1 + (mode % len(self.MODE)))
                return

    def update_menu(self):
        if self.change_mode_allowed:
            self.menu = '{}|{}\n  {}|{}\n  {}|{}\n  {}|{}'.format(
                "F1 Playback", curses.A_BOLD if self.MODE[1] else curses.A_DIM,
                "F2 Recording", curses.A_BOLD if self.MODE[2] else curses.A_DIM,
                "F3 Output Devices", curses.A_BOLD if self.MODE[3] else curses.A_DIM,
                "F4 Input Devices", curses.A_BOLD if self.MODE[4] else curses.A_DIM)
        else:
            if self.MODE[3]:
                select = 'output'
            elif self.MODE[4]:
                select = 'input'
            self.menu = "Select new {} device:|{}".format(select, curses.A_NORMAL)

    def update_info(self):
        focus = self.focus_line_num + self.top_line_num + 1
        try:
            bar, side = self.data[focus - 1][0], self.data[focus - 1][1]
        except IndexError:
            self.focus_line_num, self.top_line_num = 0, 0
            for _ in range(len(self.data)):
                self.scroll(self.UP)
            return
        if side is Bar.NONE:
            self.info = str
            return
        if bar.locked:
            top = focus - side
            if bar.channels == 1:
                n = str(top)
            else:
                bot = focus + (bar.channels - (side)) - 1
                n = '{}-{}'.format(top, bot)
            side = 'All'
        else:
            n = str(focus)
            if side is Bar.LEFT:
                side = 'Left' if bar.channels != 1 else 'Mono'
            elif side is Bar.RIGHT:
                side = 'Right'
            elif side is Bar.RLEFT:
                side = 'Rear Left'
            elif side is Bar.RRIGHT:
                side = 'Rear Right'
            elif side is Bar.CENTER:
                side = 'Center'
            elif side is Bar.SUB:
                side = 'Subwoofer'
            elif side is Bar.SLEFT:
                side = 'Side Left'
            elif side is Bar.SRIGHT:
                side = 'Side Right'
        self.info = '{:<7}|{}'.format(n + '/' + str(self.n_lines), curses.A_BOLD)
        name = '{}: {}'.format(bar.fullname, side)
        if len(name) > self.cols - 14:
            name = '{}: {}'.format(bar.fullname[:self.cols - (18 + len(side))], side)
        self.info += '\n{}|{}\n{}|{}\n{}|{}'.format(
            "L ", self.red if bar.locked else curses.A_DIM,
            "M  ", self.red if bar.muted else curses.A_DIM,
            name, curses.A_NORMAL)

    def check_resize(self):
        if curses.is_term_resized(curses.LINES, curses.COLS):
            self.screen.erase()
            y, x = self.screen.getmaxyx()
            curses.resizeterm(y, x)
            self.submenu.resize(curses.LINES, 25)
            self.helpwin.resize(12, 62)
            self.helpwin.mvwin((curses.LINES // 2) - 6, (curses.COLS // 2) - 31)
            self.helpwin_show = False
            self.screen.refresh()
        self.lines = curses.LINES - 2
        self.cols = curses.COLS

    def run(self, scr):
        signal.signal(signal.SIGINT, lambda signal, frame: sys.exit(0))
        while True:
            try:
                self.check_resize()
                if not self.submenu_show:
                    self.get_data()
                    self.update_menu()
                    self.update_info()
                    self.display()
                    if self.helpwin_show:
                        self.display_helpwin()
                        self.run_helpwin()
                        continue
                elif self.change_mode_allowed:
                    self.display_submenu()
                    self.run_submenu()
                    continue
            except curses.error as e:
                self.screen.erase()
                self.screen.addstr('Can you make it any bigger?\n')
                self.screen.addstr(str(e))

            focus = self.top_line_num + self.focus_line_num
            bar, side = self.data[focus][0], self.data[focus][1]

            c = self.screen.getch()
            if c == curses.KEY_F1:
                self.change_mode(1)
            elif c == curses.KEY_F2:
                self.change_mode(2)
            elif c == curses.KEY_F3:
                self.change_mode(3)
            elif c == curses.KEY_F4:
                self.change_mode(4)
            elif c == ord('?'):
                self.helpwin_show = True
            elif c == ord('\n'):
                if not self.submenu_show and self.change_mode_allowed and side != Bar.NONE:
                    self.selected = self.data[focus]
                    if self.active_mode == 3 or self.active_mode == 4:
                        self.submenu_data = ['Suspend', 'Resume']
                        if self.selected[0].pa.n_ports:
                            self.submenu_data.append('Set port')
                    else:
                        self.submenu_data = ['Move']
                    self.submenu_show = True
                    self.modes[4][0] = 0
                    self.modes[4][1] = self.focus_line_num
                    self.modes[4][2] = self.top_line_num
                    self.focus_line_num = self.top_line_num = 0
                    self.n_lines = len(self.submenu_data)
                elif not self.change_mode_allowed:
                    self.submenu_show = False
                    self.change_mode_allowed = True
                    if self.action == 'Move':
                        if self.old_mode == 1:
                            pulse.pulse_sink_input_move(self.selected[0].index,
                                                        self.data[focus][0].pa.index)
                        else:
                            pulse.pulse_source_output_move(self.selected[0].index,
                                                           self.data[focus][0].pa.index)
                        self.change_mode(self.old_mode)
                        self.focus_line_num = self.modes[4][1]
                        self.top_line_num = self.modes[4][2]
                    else:
                        self.change_mode(self.old_mode)
            elif c == ord('\t'):
                self.next_mode()
            elif c == ord('q') or c == self.ESC_KEY:
                if not self.change_mode_allowed:
                    self.submenu_show = False
                    self.change_mode_allowed = True
                    self.change_mode(self.old_mode)
                    self.focus_line_num = self.modes[4][1]
                    self.top_line_num = self.modes[4][2]
                elif self.helpwin_show:
                    self.helpwin_show = False
                else:
                    sys.exit()

            if side is Bar.NONE:
                continue

            if c == curses.KEY_UP or c == ord('k'):
                if bar.locked:
                    if self.data[focus][1] == 0:
                        n = 1
                    else:
                        n = self.data[focus][1] + 1
                    [self.scroll(self.UP) for _ in range(n)]
                else:
                    self.scroll(self.UP)
            elif c == curses.KEY_DOWN or c == ord('j'):
                if bar.locked:
                    if self.data[focus][1] == self.data[focus][3] - 1:
                        n = 1
                    else:
                        n = ((self.data[focus][3] - 1) - self.data[focus][1]) + 1
                    [self.scroll(self.DOWN) for _ in range(n)]
                else:
                    self.scroll(self.DOWN)

            elif c == ord('m'):
                bar.mute_toggle()
            elif c == self.SPACE_KEY:
                bar.lock_toggle()
            elif c == curses.KEY_LEFT or c == ord('h'):
                bar.move(-1, side)
            elif c == curses.KEY_RIGHT or c == ord('l'):
                bar.move(1, side)
            elif c == curses.KEY_SLEFT or c == ord('H'):
                bar.move(-10, side)
            elif c == curses.KEY_SRIGHT or c == ord('L'):
                bar.move(10, side)

    def run_submenu(self):
        c = self.screen.getch()
        if c == ord('q') or c == self.ESC_KEY:
            self.submenu_show = False
            self.focus_line_num = self.modes[4][1]
            self.top_line_num = self.modes[4][2]
        elif c == curses.KEY_UP or c == ord('k'):
            self.scroll(self.UP)
        elif c == curses.KEY_DOWN or c == ord('j'):
            self.scroll(self.DOWN)
        elif c == ord('\n'):
            focus = self.focus_line_num + self.top_line_num
            self.action = self.submenu_data[focus]
            if self.action == 'Move':
                if self.active_mode == 1:
                    self.change_mode(3)
                elif self.active_mode == 2:
                    self.change_mode(4)
                self.change_mode_allowed = self.submenu_show = False
                return
            elif self.action == 'Suspend':
                if self.active_mode == 3:
                    pulse.pulse_sink_suspend(self.selected[2], 1)
                else:
                    pulse.pulse_source_suspend(self.selected[2], 1)
            elif self.action == 'Resume':
                if self.active_mode == 3:
                    pulse.pulse_sink_suspend(self.selected[2], 0)
                else:
                    pulse.pulse_source_suspend(self.selected[2], 0)
            elif self.action == 'Set port':
                self.submenu_data = []
                for i in self.selected[0].pa.ports:
                    self.submenu_data.append(i.description.decode().strip('|'))
                    if self.selected[0].pa.active_port.name == i.name:
                        self.submenu_data[-1] = " {}|{}".format(self.submenu_data[-1], self.red)
                self.focus_line_num = self.top_line_num = 0
                return
            else:
                if self.active_mode == 3:
                    pulse.pulse_set_sink_port(self.selected[0].pa.index,
                                              self.selected[0].pa.ports[focus].name)
                elif self.active_mode == 4:
                    pulse.pulse_set_source_port(self.selected[0].pa.index,
                                                self.selected[0].pa.ports[focus].name)
            self.change_mode_allowed = True
            self.submenu_show = False
            self.focus_line_num = self.modes[4][1]
            self.top_line_num = self.modes[4][2]

    def fill(self, t, f):
        for s in f:
            found = False
            for i, data in enumerate(t):
                if s.index == data[2]:
                    found = True
                    data[0].poll_data(s)
            if not found:
                bar = Bar(s)
                for c in range(s.volume.channels):
                    t.append((bar, c, s.index, s.volume.channels))
        for i in range(len(t) - 1, -1, -1):
            found = False
            element = t[i]
            for s in f:
                if element[2] == s.index:
                    found = True
                    break
            if not found:
                del t[i]
                if self.focus_line_num + self.top_line_num >= i:
                    self.scroll(self.UP)
        return t

    def get_data(self):
        if self.MODE[1]:
            self.data = self.fill(self.modes[0][0], pulse.pulse_sink_input_list())
        elif self.MODE[2]:
            self.data = self.fill(self.modes[1][0], pulse.pulse_source_output_list())
        elif self.MODE[3]:
            self.data = self.fill(self.modes[2][0], pulse.pulse_sink_list())
        elif self.MODE[4]:
            self.data = self.fill(self.modes[3][0], pulse.pulse_source_list())

        self.n_lines = len(self.data)
        if not self.n_lines:
            self.focus_line_num = 0
            self.data.append((Bar('no data'), Bar.NONE, 0))

    def display(self):
        self.screen.erase()
        top = self.top_line_num
        bottom = self.top_line_num + self.lines
        self.display_line(0, self.menu)

        for index, line in enumerate(self.data[top:bottom]):
            line, bartype = line[0], line[1]
            linenum = self.top_line_num + index
            if bartype is Bar.NONE:
                self.screen.addstr(
                    self.lines // 2, self.cols // 2, line.name, curses.A_DIM)
                break

            # hightlight lines from same bar
            same, found = [], False
            for i, v in enumerate(self.data[:]):
                if v[0] is self.data[self.top_line_num + self.focus_line_num][0]:
                    same.append(v[0])
                    found = True
                elif found:
                    break

            if bartype == Bar.LEFT:
                if line.channels != 1:
                    brackets = ['', '']
                else:
                    brackets = ['', '']
            elif bartype == line.channels - 1:
                brackets = ['', '']
            else:
                brackets = ['', '']

            # focus current lines
            focus_hi, bracket_hi, arrow = 0, 0, ''
            if index == self.focus_line_num:
                focus_hi = bracket_hi = curses.A_BOLD
                arrow = ''
            elif line in same:
                focus_hi = curses.A_BOLD
                if line.locked:
                    bracket_hi = curses.A_BOLD
                    arrow = ''

            # highlight chosen sink/source
            if not self.change_mode_allowed and \
                    self.selected[0].owner == self.data[index][0].index:
                bracket_hi = self.red | bracket_hi

            off = 5 * (self.cols // 40)
            cols = self.cols - 32 - off
            if cols % 3:
                cols -= 1
            vol = list('-' * int(cols))
            n = int(len(vol) * line.volume[bartype] / line.maxsize)
            vol[:n] = '' * n
            vol = ''.join(vol)
            if bartype is Bar.LEFT:
                name = line.name
                if len(line.name) > 20 + off:
                    name = line.name[:20 + off] + '..'
                line = '{:<{}}|{}\n {:<3}|{}\n '.format(
                    name, 22 + off, focus_hi,
                    line.volume[0], focus_hi)
            elif bartype is Bar.RIGHT:
                line = '{:>{}}|{}\n {}|{}\n {:<3}|{}\n '.format(
                    "Locked", 15 + off, self.red if line.locked else curses.A_DIM,
                    "Muted ", self.red if line.muted else curses.A_DIM,
                    line.volume[bartype], focus_hi)
            else:
                line = '{:>{}}{:<3}|{}\n '.format(
                    '', 23 + off, line.volume[bartype], focus_hi)
            volbar = str()
            for i, v in enumerate(re.findall('.{{{}}}'.format(len(vol) // 3), vol)):
                volbar += '\n{}|{}'.format(v, self.gradient[i] | focus_hi)
            line += '{:>1}|{}\n{}|{}{}\n{}|{}\n{}|{}'.format(arrow, curses.A_BOLD,
                                                             brackets[0], bracket_hi,
                                                             volbar,
                                                             brackets[1], bracket_hi,
                                                             arrow, curses.A_BOLD)
            self.display_line(index + 1, line)
        self.display_line(self.lines + 1, self.info)
        self.screen.refresh()

    def display_helpwin(self):
        '''h/j/k/l                       navigation, volume change
          arrows                        navigation, volume change
          H/L, Shift+Left/Shift+Right   change volume by 10
          m                             mute/unmute
          Space                         lock/unlock channels together
          Enter                         context menu
          F1/F2/F3/F4                   change modes
          Tab                           go to next mode
          ?                             show help
          q/Esc/^C                      quit'''
        self.helpwin.erase()
        self.helpwin.border()
        for i, s in enumerate(self.display_helpwin.__doc__.split('\n')):
            self.helpwin.addstr(i + 1, 1, s.strip(), curses.A_NORMAL)
        self.helpwin.refresh()

    def run_helpwin(self):
        c = self.screen.getch()
        if c == ord('q') or c == self.ESC_KEY:
            self.helpwin_show = False

    def display_submenu(self):
        self.submenu.erase()
        top = self.top_line_num
        bottom = self.top_line_num + self.lines + 2
        self.submenu.vline(0, 24, curses.ACS_VLINE, self.lines + 2)
        for index, line in enumerate(self.submenu_data[top:bottom]):
            if index == self.focus_line_num:
                focus_hi = curses.A_BOLD
            else:
                focus_hi = curses.A_NORMAL
            if '|' in line:
                self.display_line(index, line, focus_hi)
            else:
                self.submenu.addstr(index, 1, line, focus_hi)
        self.submenu.refresh()

    def scroll(self, n):
        next_line_num = self.focus_line_num + n

        if n == self.UP and self.focus_line_num == 0 and self.top_line_num != 0:
            self.top_line_num += self.UP
            return
        elif n == self.DOWN and next_line_num == self.lines and\
                (self.top_line_num + self.lines) != self.n_lines:
            self.top_line_num += self.DOWN
            return

        if n == self.UP and (self.top_line_num != 0 or self.focus_line_num != 0):
            self.focus_line_num = next_line_num
        elif n == self.DOWN and\
                (self.top_line_num + self.focus_line_num + 1) != self.n_lines and\
                self.focus_line_num != self.lines:
            self.focus_line_num = next_line_num


def usage():
    print(__doc__)
    print("Interactive help:")
    for s in Screen.display_helpwin.__doc__.split('\n'):
        print(" ", s.strip())


def main():
    try:
        opts, args = getopt.getopt(
            sys.argv[1:], "hvl",
            ["help", "version", "list", "list-sinks", "list-sources", "id=",
             "set-volume=", "set-volume-all=", "change-volume=", "get-volume",
             "get-mute", "toggle-mute", "mute", "unmute"])
    except getopt.GetoptError as err:
        sys.exit("ERR: {}".format(err))

    if len(sys.argv) == 1:
        scr = Screen()
        curses.wrapper(scr.run)

    sinks = pulse.pulse_sink_list()
    sink_inputs = pulse.pulse_sink_input_list()
    sources = pulse.pulse_source_list()
    source_outputs = pulse.pulse_source_output_list()
    streams = {}
    try:
        index = sinks[0].index
    except:
        sys.exit("ERR: Can't find master sink")
    for i in source_outputs + sources + sink_inputs + sinks:
        streams[i.index] = i
    check_id = lambda x: x in streams or sys.exit('ERR: No such ID: ' + str(x))
    check_id(index)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            sys.exit(usage())

        if opt in ('-v', '--version'):
            sys.exit(print(VERSION))

        elif opt == '--id':
            index = int(arg)
            check_id(index)

        elif opt in ('-l', '--list'):
            for sink in sink_inputs:
                print("Sink input:\t", sink)
            for source in source_outputs:
                print("Source output:\t", source)
            for sink in sinks:
                print("Sink:\t\t", sink)
            for source in sources:
                print("Source:\t\t", source)

        elif opt == '--list-sinks':
            for sink in sink_inputs:
                print("Sink input:\t", sink)
            for sink in sinks:
                print("Sink:\t\t", sink)

        elif opt == '--list-sources':
            for source in source_outputs:
                print("Source output:\t", source)
            for source in sources:
                print("Source:\t\t", source)

        elif opt == '--get-mute':
            print(streams[index].mute)

        elif opt == '--mute':
            pulse.mute_stream(streams[index])

        elif opt == '--unmute':
            pulse.unmute_stream(streams[index])

        elif opt == '--toggle-mute':
            if streams[index].mute:
                pulse.unmute_stream(streams[index])
            else:
                pulse.mute_stream(streams[index])

        elif opt == '--get-volume':
            print(*streams[index].volume.values)

        elif opt == '--set-volume':
            vol = streams[index].volume
            for i, _ in enumerate(vol.values):
                vol.values[i] = int(arg)
            pulse.set_volume(streams[index], vol)

        elif opt == '--set-volume-all':
            vol = streams[index].volume
            arg = arg.strip(':').split(':')
            if len(arg) != len(vol.values):
                sys.exit("ERR: Specified volumes not equal to number of channles"
                         " in the stream")
            for i, _ in enumerate(vol.values):
                vol.values[i] = int(arg[i])
            pulse.set_volume(streams[index], vol)

        elif opt == '--change-volume':
            vol = streams[index].volume
            for i, _ in enumerate(vol.values):
                vol.values[i] += int(arg)
            pulse.set_volume(streams[index], vol)


if __name__ == '__main__':
    main()
